[TOC]



### 1. 解释型语言和编译型语言

1. 计算机不能直接理解任何除机器语言之外的语言，必须把程序员所写的程序语言翻译成机器语言才能执行程序
2. 程序语言翻译成机器语言的工具 -- 翻译器
3. 翻译器翻译方式 -- 编译Java，解释JS（翻译的时间点不同）
4. 编译器 -- **代码执行之前进行编译**，生成中间代码文件
5. 解释器 -- **运行时进行及时解释**，并立即执行

### 2. 标识符，关键字，保留字
#### 标识符
开发人员为变量，属性，函数，参数取的名字
标识符不能是关键字或者保留字

#### 关键字
JS本身已经使用了的字，不能再用它们充当变量名，方法名
break, case, default, void ...

#### 保留字
预留的“关键字”,未来可能会称为关键字
let, byte, class, throws, private

### 3. 运算符优先级

| 优先级 | 运算符     | 顺序              |
| ------ | ---------- | ----------------- |
| 1      | 小括号     | ()                |
| 2      | 一元运算符 | ++  --  !         |
| 3      | 算数运算符 | 先* / % 后 + -    |
| 4      | 关系运算符 | >  >=  <  <=      |
| 5      | 相等运算符 | ==  !=  ===   !== |
| 6      | 逻辑运算符 | 先 &&  后 \|\|    |
| 7      | 赋值运算符 | =                 |
| 8      | 逗号运算符 | ，                |

一元运算符里逻辑**非优先级很高**

逻辑与比逻辑或优先级高

### 4. 流程控制

顺序结构，分支结构，循环结构


```js
let num = 2
// 表达式的值和case里的值和类型均相匹配才全等 
switch(表达式){
    case value 1:
        执行语句1;
        break;
    case value2:
        执行语句2;
        break;
    ...
    default:
        执行最后的语句;
}
```

```js
while(条件表达式){
    // 循环体
}
```

```js
// 执行思路：先执行一次循环体，再判断条件
do{
    // 循环体
}while(条件表达式)
```

```js
continue
跳出当前循环

break
立即跳出整个循环
```



### 5. 命名规范

**标识符命名规范**

变量，函数的命名必须有意义

变量的名称一般用名词

函数的名称一般用动词

**操作符规范**

操作符左右两侧各保留一个空格

```javascript
let sum = 0;

for (let i = 0; i <= 100; i++) {

 if (i % 7 == 0) {

  continue;

 }

 sum += i;

}

console.log(sum);
```

### 6. 函数
#### 函数
封装了一段可被重复调用执行的代码块，允许代码重复使用
#### 函数的封装
一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口
#### 函数的参数

```js
// 形式上的参数 -- 接收实参，相当于一个变量
function 函数名(形参) {
    
}
// 实际参数
函数名(实参)

// 若实参的个数与形参个数一致，则正常输出结果
// 若实参个数多于形参个数，会取到形参的个数
// 若实参的个数小于形参个数，多余形参定义为undefined,结果为NaN
```
函数只是实现某种功能，最终结果需要返回给函数的调用者函数名（）通过return实现

#### 函数返回值注意事项

1. return终止函数

```js
// return 后面的代码不会被执行
function getSum(a,b){
    return a+b
    alert("不会被执行")
}
console.log(getSum(1,2))
```

2. return只能返回一个值，如果用逗号隔开，以最后一个为准

```js
function fn(a,b){
    // 只返回最后一个值
    return a,b
}

console.log(fn(3,4));
```
3. 函数如果有return 返回return后面的值，没有则返回undefined
4. break，continue,return 
   **break**:结束当前循环体
   **continue**:跳出本次循环，继续执行下次循环
   **return**:不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码

#### arguments的使用

不确定有多少个参数传递时，可用arguments获取

在js中，所有函数内置了一个arguments对象，存储了传递的所有实参

arguments的展示形式是一个伪数组，特点：

- 具有length属性
- 按索引方式存储数据
- 不具有push,pop等方法

### 7. 作用域

 #### 作用域

 代码名字在某个范围内起作用和效果

 提高了程序逻辑的局部性，增强了程序的可靠性，减少命名冲突

#### js的作用域(es6): 

全局作用域:整个script标签，或者是一个单独的js文件

局部作用域:在函数内部起效果

### 8.变量的作用域

#### 全局变量

在函数内部没有声明直接赋值的变量也属于全局变量

全局作用域下的变量

#### 局部变量

局部作用域下的变量，后者在函数内部的变量就是局部变量

函数的形参也是局部变量

#### 从执行效率来看全部变量和局部变量

全局变量只有**浏览器关闭的时候才会销毁**，**比较占内存资源**

局部变量 -- 当我们程序执行完毕就会销毁

js在ES6的时候新增块级作用域

### 9. 作用域链

如果函数中还有函数，在这个作用域中就又诞生一个作用域

根据**内部函数可以访问外部函数**的机制，用**链式**查找决定哪些数据可以被内部函数访问，称为**作用域链**

### 10. 预解析

js 由浏览器中的JavaScript解析器来执行，js解析器在运行js代码的时候分两步：

预解析，代码执行

```js
/**
 * 预解析，代码执行
 * 1. 预解析:js引擎会把js里面所有的var，还有function提升到当前作用域的最前面
 * 2. 代码执行：按照代码书写的顺序从上往下执行
 * 预解析分为 变量预解析(变量提升) 和 函数预解析(函数提升)
 * 变量提升：把所有的变量声明提升到当前的作用域的最前面，不提升赋值操作
 * 函数提升：把所有的函数声明提升到当前作用域的最前面 不调用函数
 */
```

### 11. 对象

对像是一组无需的相关属性和方法的集合

属性：事物的特征，在对象中用属性来表示

方法：事物的行为，在对象中用方法来表示

#### 创建对象

- 利用字面量创建对象

- 利用new object创建对象

- 利用构造函数创建对象


#### 变量，属性，函数，方法的区别

变量和属性相同，用来**存储数据**

变量 - **单独声明并赋值**，使用的时候直接写变量名，单独存在

属性 - **对象里不需要声明**，使用的时候必须是对象.属性



函数和方法的相同点 -- 都是实现某种功能，做某件事

函数是单独声明并且调用的，调用 -- 函数名（）

方法在对象里面，调用 -- 对象.方法

```js
//函数
function sayHi(){
    
}

let a = {
    uname:"abc",
    age:88,
    //方法
    sayHi:function(){
        console.log("hi");
    }
}
```



#### 构造函数和对象对比

```js
// 1. 构造函数 -- 泛指的某一大类，类似于类(class)
function Star(name,age,sex){
    // 设置公共属性
    this.name = name
    this.age = age
    this.sex = sex
    this.reading = function(){
        console.log(`${this.name} can read books`);
    }
}
// 调用函数返回的是一个对象
let starObject = new Star("Bella",26,"female")
let myObject = new Star("Mike",22,"male")
// 2. 对象是一个具体的事物
// Star {
//     name: 'Bella',
//     age: 26,
//     sex: 'female',
//     reading: [Function (anonymous)]
//   }
console.log(starObject);
console.log(typeof starObject); // objects
console.log(starObject.name);
console.log(starObject['sex']);
console.log(myObject.name);
myObject.reading()

// 3. 利用构造函数创建对象称为对象的实例化

new 执行过程

```

